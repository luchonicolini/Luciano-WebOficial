[
    {
        "id": "1",
        "tag": "Desarrollo",
        "icon": "fas fa-laptop-code",
        "title": "Introducci칩n al Desarrollo Web",
        "date": "5 de enero, 2025",
        "excerpt": "Aprende los fundamentos del desarrollo web y c칩mo crear tu primer sitio web desde cero. Cubriremos las herramientas y tecnolog칤as esenciales...",
        "content": "Aprender los fundamentos del desarrollo web es el primer paso para construir una carrera emocionante en tecnolog칤a. El desarrollo web se divide en dos 치reas principales: frontend y backend. El frontend se encarga de todo lo que el usuario ve y con lo que interact칰a, mientras que el backend maneja la l칩gica del servidor y las bases de datos. Para empezar, necesitar치s dominar tres tecnolog칤as clave: HTML, CSS y JavaScript. HTML (HyperText Markup Language) estructura el contenido de la p치gina. CSS (Cascading Style Sheets) le da estilo al contenido, controlando colores, fuentes y dise침o. JavaScript a침ade interactividad, permitiendo que la p치gina responda a las acciones del usuario. Juntas, estas tres tecnolog칤as forman la base de casi cualquier sitio web moderno. Empieza creando una p치gina simple con cada una de ellas para familiarizarte con su funcionamiento."
    },
    {
        "id": "2",
        "tag": "Dise침o",
        "icon": "fas fa-paint-brush",
        "title": "Principios del Dise침o Web Moderno",
        "date": "2 de enero, 2025",
        "excerpt": "Descubre los principios clave que hacen que los sitios web modernos sean tanto hermosos como funcionales. Desde teor칤a del color hasta tipograf칤a...",
        "content": "El dise침o web moderno no se trata solo de hacer que un sitio se vea bonito, sino de crear una experiencia de usuario intuitiva y agradable. Un principio fundamental es la simplicidad; un dise침o limpio y sin desorden ayuda al usuario a encontrar lo que busca r치pidamente. El color juega un papel crucial en el estado de 치nimo y la identidad de la marca. Una paleta de colores cohesiva puede hacer que un sitio se sienta profesional y unificado. La tipograf칤a tambi칠n es esencial; la elecci칩n de las fuentes y su espaciado pueden mejorar significativamente la legibilidad. Finalmente, la capacidad de respuesta (responsive design) es obligatoria hoy en d칤a, asegurando que el sitio se vea y funcione bien en cualquier dispositivo, desde un m칩vil hasta un ordenador de escritorio."
    },
    {
        "id": "3",
        "tag": "Firebase",
        "icon": "fas fa-database",
        "title": "Integrando Firebase en tu App iOS",
        "date": "8 de enero, 2025",
        "excerpt": "Una gu칤a paso a paso para conectar tu aplicaci칩n SwiftUI con Firebase para autenticaci칩n y base de datos.",
        "content": "Firebase, la plataforma de desarrollo de aplicaciones de Google, ofrece una suite de herramientas que pueden acelerar significativamente el desarrollo de aplicaciones iOS. Para empezar, necesitar치s crear un proyecto en la consola de Firebase e instalar el SDK de Firebase en tu proyecto de Xcode usando CocoaPods o Swift Package Manager. Una vez configurado, puedes utilizar servicios como Firestore para bases de datos NoSQL, Authentication para gestionar usuarios, y Cloud Storage para almacenar archivos. Por ejemplo, para la autenticaci칩n, solo necesitas importar `Firebase/Auth` e implementar unas pocas l칤neas de c칩digo para permitir a los usuarios registrarse o iniciar sesi칩n con correo electr칩nico y contrase침a. Esto te permite enfocarte en la funcionalidad principal de tu app, dejando la complejidad del backend a Firebase."
    },
    {
        "id": "4",
        "tag": "SwiftUI",
        "icon": "fab fa-swift",
        "title": "C칩mo Usar Vistas Modales en SwiftUI",
        "date": "15 de enero, 2025",
        "excerpt": "Aprende a presentar vistas de forma modal para mostrar informaci칩n temporal o flujos de trabajo en tus apps iOS.",
        "content": "Las vistas modales en SwiftUI son una forma poderosa de mostrar contenido temporal que se superpone a la vista actual. Son ideales para formularios de entrada, alertas o informaci칩n adicional que requiere la atenci칩n del usuario. Para presentar una vista modal, se utiliza el modificador `.sheet()`. Este modificador toma un `Binding` a un valor booleano (`@State var isShowingModal = false`) que controla si la vista se muestra o no. Cuando el valor se establece en `true`, la vista modal se presenta. Al cerrarla, el valor se vuelve a `false`. Esto proporciona una manera declarativa y limpia de gestionar las transiciones de la interfaz de usuario en tus aplicaciones SwiftUI."
    },
    {
    "id": "5",
    "tag": "SwiftUI",
    "icon": "fab fa-swift",
    "title": "Creando una Lista Din치mica en SwiftUI",
    "date": "20 de enero, 2025",
    "excerpt": "Aprende a crear listas din치micas e interactivas en SwiftUI con navegaci칩n, eliminaci칩n y datos personalizados paso a paso.",
    "content": "<h2>Introducci칩n a las Listas en SwiftUI</h2><p>Las listas son uno de los componentes m치s utilizados en aplicaciones m칩viles. SwiftUI nos proporciona una manera elegante y sencilla de crear listas din치micas que se adaptan autom치ticamente a los datos y ofrecen interactividad nativa.</p><p>En este art칤culo, construiremos una lista de tareas completa con funcionalidades de adici칩n, eliminaci칩n y navegaci칩n.</p><h3>Definiendo el Modelo de Datos</h3><p>Primero, creamos una estructura para representar nuestras tareas:</p><pre><code>import SwiftUI\n\nstruct Task: Identifiable, Codable {\n    let id = UUID()\n    var title: String\n    var description: String\n    var isCompleted: Bool = false\n    var priority: Priority\n    \n    enum Priority: String, CaseIterable, Codable {\n        case low = \"Baja\"\n        case medium = \"Media\"\n        case high = \"Alta\"\n        \n        var color: Color {\n            switch self {\n            case .low: return .green\n            case .medium: return .orange\n            case .high: return .red\n            }\n        }\n    }\n}</code></pre><blockquote><p>游눠 <strong>Tip:</strong> El protocolo <code>Identifiable</code> es esencial para que SwiftUI pueda identificar 칰nicamente cada elemento de la lista.</p></blockquote><h3>Creando la Vista Principal</h3><p>Ahora implementamos la vista que contendr치 nuestra lista:</p><pre><code>struct TaskListView: View {\n    @State private var tasks: [Task] = [\n        Task(title: \"Estudiar SwiftUI\", description: \"Repasar conceptos b치sicos\", priority: .high),\n        Task(title: \"Hacer ejercicio\", description: \"Correr 30 minutos\", priority: .medium),\n        Task(title: \"Leer libro\", description: \"Continuar con el cap칤tulo 5\", priority: .low)\n    ]\n    \n    @State private var showingAddTask = false\n    \n    var body: some View {\n        NavigationView {\n            List {\n                ForEach(tasks) { task in\n                    TaskRowView(task: task) {\n                        toggleTaskCompletion(task)\n                    }\n                }\n                .onDelete(perform: deleteTasks)\n            }\n            .navigationTitle(\"Mis Tareas\")\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(action: { showingAddTask = true }) {\n                        Image(systemName: \"plus\")\n                    }\n                }\n            }\n            .sheet(isPresented: $showingAddTask) {\n                AddTaskView { newTask in\n                    tasks.append(newTask)\n                }\n            }\n        }\n    }\n    \n    private func toggleTaskCompletion(_ task: Task) {\n        if let index = tasks.firstIndex(where: { $0.id == task.id }) {\n            tasks[index].isCompleted.toggle()\n        }\n    }\n    \n    private func deleteTasks(offsets: IndexSet) {\n        tasks.remove(atOffsets: offsets)\n    }\n}</code></pre><h3>Vista de Fila Personalizada</h3><p>Creamos una vista personalizada para cada fila de la lista:</p><pre><code>struct TaskRowView: View {\n    let task: Task\n    let onToggle: () -> Void\n    \n    var body: some View {\n        HStack {\n            Button(action: onToggle) {\n                Image(systemName: task.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                    .foregroundColor(task.isCompleted ? .green : .gray)\n                    .font(.title2)\n            }\n            .buttonStyle(PlainButtonStyle())\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(task.title)\n                    .font(.headline)\n                    .strikethrough(task.isCompleted)\n                    .foregroundColor(task.isCompleted ? .secondary : .primary)\n                \n                Text(task.description)\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n                    .lineLimit(2)\n            }\n            \n            Spacer()\n            \n            Text(task.priority.rawValue)\n                .font(.caption)\n                .padding(.horizontal, 8)\n                .padding(.vertical, 4)\n                .background(task.priority.color.opacity(0.2))\n                .foregroundColor(task.priority.color)\n                .clipShape(Capsule())\n        }\n        .padding(.vertical, 4)\n    }\n}</code></pre><h3>Vista para Agregar Tareas</h3><p>Finalmente, implementamos la vista modal para agregar nuevas tareas:</p><pre><code>struct AddTaskView: View {\n    @Environment(\\.dismiss) private var dismiss\n    let onSave: (Task) -> Void\n    \n    @State private var title = \"\"\n    @State private var description = \"\"\n    @State private var selectedPriority = Task.Priority.medium\n    \n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"Informaci칩n de la Tarea\") {\n                    TextField(\"T칤tulo\", text: $title)\n                    TextField(\"Descripci칩n\", text: $description, axis: .vertical)\n                        .lineLimit(3...6)\n                }\n                \n                Section(\"Prioridad\") {\n                    Picker(\"Prioridad\", selection: $selectedPriority) {\n                        ForEach(Task.Priority.allCases, id: \\.self) { priority in\n                            HStack {\n                                Circle()\n                                    .fill(priority.color)\n                                    .frame(width: 12, height: 12)\n                                Text(priority.rawValue)\n                            }\n                            .tag(priority)\n                        }\n                    }\n                    .pickerStyle(SegmentedPickerStyle())\n                }\n            }\n            .navigationTitle(\"Nueva Tarea\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarLeading) {\n                    Button(\"Cancelar\") {\n                        dismiss()\n                    }\n                }\n                \n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Guardar\") {\n                        let newTask = Task(\n                            title: title,\n                            description: description,\n                            priority: selectedPriority\n                        )\n                        onSave(newTask)\n                        dismiss()\n                    }\n                    .disabled(title.isEmpty)\n                }\n            }\n        }\n    }\n}</code></pre><h2>Funcionalidades Implementadas</h2><p>Nuestra aplicaci칩n de lista de tareas incluye las siguientes caracter칤sticas:</p><ul><li><strong>Lista din치mica:</strong> Muestra tareas con informaci칩n detallada</li><li><strong>Interactividad:</strong> Marcar tareas como completadas con un toque</li><li><strong>Eliminaci칩n:</strong> Deslizar para eliminar tareas</li><li><strong>Adici칩n:</strong> Modal para crear nuevas tareas</li><li><strong>Prioridades:</strong> Sistema de colores para diferentes niveles</li><li><strong>Persistencia visual:</strong> Estados visuales para tareas completadas</li></ul><blockquote><p>游꿢 <strong>Resultado:</strong> Una aplicaci칩n completamente funcional que demuestra el poder y simplicidad de SwiftUI para crear interfaces complejas.</p></blockquote><h3>Mejoras Adicionales</h3><p>Para llevar esta aplicaci칩n al siguiente nivel, considera implementar:</p><ol><li><strong>Persistencia de datos:</strong> Usar Core Data o UserDefaults</li><li><strong>Animaciones:</strong> Transiciones suaves al marcar completadas</li><li><strong>Filtros:</strong> Mostrar solo tareas pendientes o completadas</li><li><strong>B칰squeda:</strong> Barra de b칰squeda para encontrar tareas espec칤ficas</li><li><strong>Categor칤as:</strong> Organizar tareas por categor칤as</li></ol><h2>Conclusi칩n</h2><p>Las listas en SwiftUI son incre칤blemente poderosas y flexibles. Con relativamente poco c칩digo, hemos creado una aplicaci칩n completa con funcionalidades avanzadas. La naturaleza declarativa de SwiftUI hace que el c칩digo sea f치cil de leer, mantener y extender.</p><p>Este ejemplo demuestra c칩mo SwiftUI maneja autom치ticamente actualizaciones de la interfaz, animaciones y la gesti칩n de estado, permiti칠ndonos enfocarnos en la l칩gica de nuestra aplicaci칩n.</p>"
},
{
    "id": "6",
    "tag": "SwiftUI",
    "icon": "fab fa-swift",
    "title": "Creando Animaciones Fluidas y Transiciones Personalizadas",
    "date": "30 de enero, 2025",
    "excerpt": "Domina las animaciones en SwiftUI creando transiciones suaves, efectos visuales impactantes y micro-interacciones que mejoran la experiencia del usuario.",
    "content": "<h2>El Poder de las Animaciones en SwiftUI</h2><p>Las animaciones son fundamentales para crear experiencias de usuario atractivas y fluidas. SwiftUI hace que crear animaciones complejas sea sorprendentemente simple, permiti칠ndonos agregar vida a nuestras interfaces con pocas l칤neas de c칩digo.</p><p>En este art칤culo, construiremos una aplicaci칩n de tarjetas interactivas con m칰ltiples tipos de animaciones y transiciones.</p><h3>Configurando los Modelos Base</h3><p>Comenzamos definiendo nuestros datos y estados:</p><pre><code>import SwiftUI\n\nstruct Card: Identifiable {\n    let id = UUID()\n    var title: String\n    var subtitle: String\n    var color: Color\n    var icon: String\n    var isExpanded: Bool = false\n    var offset: CGSize = .zero\n}\n\nclass CardsViewModel: ObservableObject {\n    @Published var cards: [Card] = [\n        Card(title: \"Desarrollo\", subtitle: \"Proyectos activos\", color: .blue, icon: \"laptopcomputer\"),\n        Card(title: \"Dise침o\", subtitle: \"Ideas creativas\", color: .purple, icon: \"paintbrush.fill\"),\n        Card(title: \"Marketing\", subtitle: \"Estrategias\", color: .orange, icon: \"megaphone.fill\")\n    ]\n    \n    @Published var selectedCard: Card?\n    @Published var showingDetail = false\n}</code></pre><h3>Vista Principal con Animaciones de Lista</h3><p>Implementamos la vista principal con animaciones fluidas:</p><pre><code>struct AnimatedCardsView: View {\n    @StateObject private var viewModel = CardsViewModel()\n    @State private var animateOnAppear = false\n    @Namespace private var cardNamespace\n    \n    var body: some View {\n        NavigationView {\n            ScrollView {\n                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 20) {\n                    ForEach(Array(viewModel.cards.enumerated()), id: \\.element.id) { index, card in\n                        CardView(card: card, namespace: cardNamespace)\n                            .onTapGesture {\n                                selectCard(card)\n                            }\n                            .scaleEffect(animateOnAppear ? 1 : 0.8)\n                            .opacity(animateOnAppear ? 1 : 0)\n                            .animation(\n                                .spring(response: 0.6, dampingFraction: 0.8)\n                                .delay(Double(index) * 0.1),\n                                value: animateOnAppear\n                            )\n                    }\n                }\n                .padding()\n            }\n            .navigationTitle(\"Tarjetas Animadas\")\n            .onAppear {\n                withAnimation {\n                    animateOnAppear = true\n                }\n            }\n        }\n        .fullScreenCover(item: $viewModel.selectedCard) { card in\n            CardDetailView(card: card, namespace: cardNamespace) {\n                dismissCard()\n            }\n        }\n    }\n    \n    private func selectCard(_ card: Card) {\n        viewModel.selectedCard = card\n    }\n    \n    private func dismissCard() {\n        withAnimation(.easeInOut(duration: 0.3)) {\n            viewModel.selectedCard = nil\n        }\n    }\n}</code></pre><h3>Tarjeta con Animaciones Interactivas</h3><p>Creamos tarjetas que responden a la interacci칩n del usuario:</p><pre><code>struct CardView: View {\n    let card: Card\n    let namespace: Namespace.ID\n    @State private var isPressed = false\n    @State private var dragOffset = CGSize.zero\n    @State private var rotationAngle: Double = 0\n    \n    var body: some View {\n        VStack(spacing: 16) {\n            // Icono con animaci칩n de rotaci칩n\n            Image(systemName: card.icon)\n                .font(.system(size: 40, weight: .light))\n                .foregroundColor(.white)\n                .rotationEffect(.degrees(rotationAngle))\n                .animation(.easeInOut(duration: 2).repeatForever(autoreverses: true), value: rotationAngle)\n            \n            VStack(spacing: 8) {\n                Text(card.title)\n                    .font(.title2)\n                    .fontWeight(.bold)\n                    .foregroundColor(.white)\n                \n                Text(card.subtitle)\n                    .font(.caption)\n                    .foregroundColor(.white.opacity(0.8))\n            }\n        }\n        .frame(height: 160)\n        .frame(maxWidth: .infinity)\n        .background(\n            RoundedRectangle(cornerRadius: 20)\n                .fill(\n                    LinearGradient(\n                        colors: [card.color, card.color.opacity(0.7)],\n                        startPoint: .topLeading,\n                        endPoint: .bottomTrailing\n                    )\n                )\n                .matchedGeometryEffect(id: \"card-\\(card.id)\", in: namespace)\n        )\n        .scaleEffect(isPressed ? 0.95 : 1.0)\n        .rotationEffect(.degrees(Double(dragOffset.width / 20)))\n        .offset(dragOffset)\n        .animation(.interactiveSpring(response: 0.4, dampingFraction: 0.6), value: isPressed)\n        .animation(.interactiveSpring(response: 0.3, dampingFraction: 0.7), value: dragOffset)\n        .onAppear {\n            rotationAngle = 15\n        }\n        .gesture(\n            DragGesture()\n                .onChanged { value in\n                    dragOffset = value.translation\n                }\n                .onEnded { _ in\n                    withAnimation(.spring()) {\n                        dragOffset = .zero\n                    }\n                }\n        )\n        .onLongPressGesture(minimumDuration: 0) { _ in\n            // Pressed\n        } onPressingChanged: { pressing in\n            withAnimation(.easeInOut(duration: 0.2)) {\n                isPressed = pressing\n            }\n        }\n        .shadow(color: card.color.opacity(0.3), radius: isPressed ? 5 : 15, x: 0, y: isPressed ? 2 : 8)\n    }\n}</code></pre><h3>Vista de Detalle con Transici칩n Hero</h3><p>Implementamos una transici칩n tipo \"hero\" entre la tarjeta y su detalle:</p><pre><code>struct CardDetailView: View {\n    let card: Card\n    let namespace: Namespace.ID\n    let onDismiss: () -> Void\n    \n    @State private var showingContent = false\n    @State private var dragOffset = CGSize.zero\n    \n    var body: some View {\n        ZStack {\n            // Background\n            card.color\n                .ignoresSafeArea()\n            \n            VStack {\n                // Header con transici칩n matchedGeometry\n                VStack(spacing: 20) {\n                    Image(systemName: card.icon)\n                        .font(.system(size: 80, weight: .ultraLight))\n                        .foregroundColor(.white)\n                    \n                    VStack(spacing: 8) {\n                        Text(card.title)\n                            .font(.largeTitle)\n                            .fontWeight(.bold)\n                            .foregroundColor(.white)\n                        \n                        Text(card.subtitle)\n                            .font(.title3)\n                            .foregroundColor(.white.opacity(0.8))\n                    }\n                }\n                .frame(height: 300)\n                .frame(maxWidth: .infinity)\n                .background(\n                    RoundedRectangle(cornerRadius: 30)\n                        .fill(card.color)\n                        .matchedGeometryEffect(id: \"card-\\(card.id)\", in: namespace)\n                )\n                .offset(y: dragOffset.height * 0.1)\n                \n                // Contenido adicional\n                if showingContent {\n                    ScrollView {\n                        VStack(alignment: .leading, spacing: 20) {\n                            ForEach(0..<5) { index in\n                                DetailRowView(index: index)\n                                    .transition(.asymmetric(\n                                        insertion: .move(edge: .trailing).combined(with: .opacity),\n                                        removal: .move(edge: .leading).combined(with: .opacity)\n                                    ))\n                                    .animation(\n                                        .spring(response: 0.6, dampingFraction: 0.8)\n                                        .delay(Double(index) * 0.1),\n                                        value: showingContent\n                                    )\n                            }\n                        }\n                        .padding()\n                    }\n                    .background(Color.white)\n                    .cornerRadius(30, corners: [.topLeft, .topRight])\n                }\n                \n                Spacer(minLength: 0)\n            }\n        }\n        .offset(y: dragOffset.height)\n        .gesture(\n            DragGesture()\n                .onChanged { value in\n                    if value.translation.height > 0 {\n                        dragOffset = value.translation\n                    }\n                }\n                .onEnded { value in\n                    if value.translation.height > 100 {\n                        onDismiss()\n                    } else {\n                        withAnimation(.spring()) {\n                            dragOffset = .zero\n                        }\n                    }\n                }\n        )\n        .onAppear {\n            withAnimation(.easeOut(duration: 0.5).delay(0.2)) {\n                showingContent = true\n            }\n        }\n        .navigationBarHidden(true)\n    }\n}\n\nstruct DetailRowView: View {\n    let index: Int\n    @State private var isHighlighted = false\n    \n    var body: some View {\n        HStack {\n            Circle()\n                .fill(Color.blue.opacity(0.2))\n                .frame(width: 40, height: 40)\n                .overlay(\n                    Text(\"\\(index + 1)\")\n                        .font(.headline)\n                        .foregroundColor(.blue)\n                )\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(\"Elemento \\(index + 1)\")\n                    .font(.headline)\n                \n                Text(\"Descripci칩n detallada del elemento\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            \n            Spacer()\n            \n            Image(systemName: \"chevron.right\")\n                .foregroundColor(.secondary)\n        }\n        .padding()\n        .background(\n            RoundedRectangle(cornerRadius: 12)\n                .fill(isHighlighted ? Color.blue.opacity(0.1) : Color.clear)\n        )\n        .onTapGesture {\n            withAnimation(.easeInOut(duration: 0.2)) {\n                isHighlighted.toggle()\n            }\n            \n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n                withAnimation(.easeInOut(duration: 0.2)) {\n                    isHighlighted = false\n                }\n            }\n        }\n    }\n}\n\n// Extension para esquinas espec칤ficas\nextension View {\n    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {\n        clipShape(RoundedCorner(radius: radius, corners: corners))\n    }\n}\n\nstruct RoundedCorner: Shape {\n    var radius: CGFloat = .infinity\n    var corners: UIRectCorner = .allCorners\n    \n    func path(in rect: CGRect) -> Path {\n        let path = UIBezierPath(\n            roundedRect: rect,\n            byRoundingCorners: corners,\n            cornerRadii: CGSize(width: radius, height: radius)\n        )\n        return Path(path.cgPath)\n    }\n}</code></pre><h2>Tipos de Animaciones Implementadas</h2><p>Nuestra aplicaci칩n demuestra varios tipos de animaciones:</p><ul><li><strong>Animaciones de entrada:</strong> Escala y opacidad con delay escalonado</li><li><strong>Animaciones interactivas:</strong> Respuesta a gestos de tap y drag</li><li><strong>Transiciones hero:</strong> matchedGeometryEffect para transiciones fluidas</li><li><strong>Animaciones impl칤citas:</strong> Cambios autom치ticos de propiedades</li><li><strong>Animaciones expl칤citas:</strong> Control total sobre timing y curvas</li><li><strong>Micro-interacciones:</strong> Feedback visual inmediato</li></ul><blockquote><p>游꿢 <strong>Resultado:</strong> Una aplicaci칩n con animaciones profesionales que mejoran significativamente la experiencia del usuario.</p></blockquote><h3>Mejores Pr치cticas para Animaciones</h3><ol><li><strong>Usa spring animations:</strong> Se sienten m치s naturales</li><li><strong>Agrega delays:</strong> Crea ritmo y jerarqu칤a visual</li><li><strong>Respeta la accesibilidad:</strong> Considera usuarios con sensibilidad al movimiento</li><li><strong>Mant칠n consistencia:</strong> Usa duraciones y curvas similares</li><li><strong>No abuses:</strong> Menos es m치s en animaciones</li></ol>"
}

    
]